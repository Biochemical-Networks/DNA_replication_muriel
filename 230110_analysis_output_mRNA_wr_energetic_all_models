"""
21-11-22, Muriel Louman, AMOLF

analysis 221121_grow_mRNA_wr_energetic_Jennys_way_test_rates
"""

#import needed packages
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math
import datetime
import os.path

def date_now(now):
    year = '{:02d}'.format(now.year)
    month = f'{now.month}' 
    day = f'{now.day}' 
    string_date = year + month + day
    print(string_date)
    return string_date

def graph_equilibration_check(length_polymer, error_prob,delta_g_bb, delta_g_tt, model):
    plt.plot(length_polymer, error_prob, label = "$\Delta G_{bb}$ = %s, $\Delta G_{tt}$ = %s"%(delta_g_bb, delta_g_tt))
    plt.title("Energetic: model: %s, Check when error is equilibrated as function of the length of the mRNA grown for different $\Delta G_{bb}$ and $\Delta G_{tt}$" %model)
    plt.xlabel("length mRNA")
    plt.ylabel("$\epsilon$")
    plt.legend(bbox_to_anchor=(1.04, 1))
    plt.subplots_adjust(right=0.7)
    return

def graph_error_g_bb(L_delta_g_bb, L_epsilon, model, delta_g_tt):
    plt.plot(L_delta_g_bb, L_epsilon, label = "$\Delta G_{tt}$ = %s" %delta_g_tt)
    plt.title("Energetic: effect $\Delta G_{pol}$ in error of mRNA string, with model %s"%(model))
    plt.xlabel("$\Delta G_{pol}$")
    plt.ylabel("$\epsilon$")
    plt.legend(bbox_to_anchor=(1.04, 1))
    plt.subplots_adjust(right=0.7)
    return

def graph_V_G_pol(L_delta_g_bb, L_V, model, delta_g_tt):
    plt.plot(L_delta_g_bb, L_V, label = "$\Delta G_{tt}$ = %s" %(delta_g_tt))
    plt.title("Energetic: effect $\Delta G_{pol}$ on how fast the polymer grows, with model =%s"%model)
    plt.xlabel("$\Delta G_{pol}$")
    plt.ylabel("V")
    plt.legend(bbox_to_anchor=(1.04, 1))
    plt.subplots_adjust(right=0.7)
    return

def graph_error_V(L_V, L_epsilon, model, delta_g_tt):
    plt.plot(L_V, L_epsilon, label = "$\Delta G_{tt}$ = %s" %(delta_g_tt))
    plt.title("Energetic: effect velocity polymer growth on the error probability, with model = %s"%(model))
    plt.xlabel("V")
    plt.ylabel("$\epsilon$")
    plt.legend(bbox_to_anchor=(1.04, 1))
    plt.subplots_adjust(right=0.7)
    return

def forward_backward_categorise(row):
    if row['monomer added removed'] == '1' or row['monomer added removed'] == '0':
        return 'f'
    elif row['monomer added removed'] == 'n':
        return 'n'
    return 'b'

def define_V(data):
    data['f or b'] = data.apply(lambda row: forward_backward_categorise(row), axis=1)
    series = data['f or b'].value_counts()
    if 'b' in series:
        b = data['f or b'].value_counts().b
    else: 
        b = 0
    if 'f' in series:
        f = data['f or b'].value_counts().f
    else: 
        f = 0
    if 'n' in series:
        n = data['f or b'].value_counts().n
    else: 
        n = 0
    V = f/(f+b+n)
    return V

def make_model_names(x_def, M_model, models, models_lose):
    L_models = []
    for x in x_def:
        for M in M_model:
            for model in models:
                model = model + M + "_" + x
                L_models.append(model)
    for mod in models_lose:
        L_models.append(mod)
    return L_models

L_delta_g_pol_string = [0,1,2,3,4,5,6,7,8,9,10]
L_delta_g_pol_label = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]
L_delta_g_pol_number = [0,1,2,3,4,5,6,7,8,9,10]
L_delta_g_tt = [0,1,2,3,4,6,8,10]

models = ["muriel_big_abs_step0_", "no_abs_matrix_step0_", "muriel_step0_"]
all_steps = False
DIR = "230110output"
x_def = ["xdelta_g_tt_pow2", "x1"]
M_model = ["M1", "M2"]
# number_steps = 0

L_models = make_model_names(x_def, M_model, models, ["Jenny_step0_full_steps"])
date = date_now(datetime.datetime.now())
date = "2023112"

for model in L_models:
    for delta_g_tt in L_delta_g_tt:
        L_epsilon = []
        L_delta_g_bb_graph = []
        L_velocity = []
        for i,delta_g_pol in enumerate(L_delta_g_pol_number):          
            # print('%smodel_%s_delta_g_pol_%s_delta_g_tt_%s.csv'%(date, model, L_delta_g_pol_string[i], delta_g_tt))                                                
            file_exists = os.path.exists('/home/ipausers/louman/Documents/programming/DNA_replication_muriel/outs/%s/%smodel_%s_delta_g_pol_%s_delta_g_tt_%s.csv'%(DIR, date, model, L_delta_g_pol_string[i], delta_g_tt))
            if file_exists == True:
                data = pd.read_csv('/home/ipausers/louman/Documents/programming/DNA_replication_muriel/outs/%s/%smodel_%s_delta_g_pol_%s_delta_g_tt_%s.csv'%(DIR, date, model, L_delta_g_pol_string[i], delta_g_tt))
                epsilon = data['error probability'].iloc[-2] #.iloc[-50:-1].mean(axis=0)
                L_epsilon.append(epsilon)
                L_delta_g_bb_graph.append(delta_g_pol)
                # template = data['monomer added removed'][-1:]
                # data=data.drop(data.index[-1])
                
                
                # # check epsilon geequilibreerd
                # graph_equilibration_check(data['length polymer'], data['error probability'],L_delta_g_pol_label[i], delta_g_tt, model)

                #add if it was a forward or backward reaction and calculate v = f/(f+b)
                # L_velocity.append(define_V(data))


            else:
                print("file does not exist")

        # print(L_delta_g_bb_graph, L_epsilon)

        #define error as all mismatches and plot the error as function of delta G_bb
        graph_error_g_bb(L_delta_g_bb_graph, L_epsilon, model, delta_g_tt)

        #make V verus G_pol graph
        # graph_V_G_pol(L_delta_g_bb_graph, L_velocity, model, delta_g_tt)

        #make error verus V graph
        # graph_error_V(L_velocity, L_epsilon, model, delta_g_tt)

    plt.show()


